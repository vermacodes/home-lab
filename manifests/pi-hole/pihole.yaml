# This ConfigMap contains environment variables for Pi-hole configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: pihole-config
data:
  TZ: "America/New_York"
  FTLCONF_dns_upstreams: "1.1.1.1;1.0.0.1"
  FTLCONF_webserver_interface_theme: "default-dark"
  FTLCONF_dns_listeningMode: "all"
  FTLCONF_dns_cache_size: "10000"
  FTLCONF_files_database: "/etc/pihole/pihole-FTL.db"
  FTLCONF_files_gravity: "/etc/pihole/gravity.db"
  FTLCONF_files_macvendor: "/etc/pihole/macvendor.db"
  FTLCONF_dns_rateLimit_count: "1000"
  FTLCONF_dns_rateLimit_interval: "60"
  FTLCONF_dns_ignoreLocalhost: "false"
  FTLCONF_dns_domain: "local"
  FTLCONF_misc_dnsmasq_lines: "no-0x20-encode"
  FTLCONF_webserver_api_password: "admin"
---
# This StatefulSet deploys the Pi-hole application with read-write access
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: pi-hole-rw
  labels:
    app.kubernetes.io/name: pi-hole
    pi.hole/role: read-write
spec:
  revisionHistoryLimit: 3
  selector:
    matchLabels:
      app.kubernetes.io/name: pi-hole
      pi.hole/role: read-write
  serviceName: "pi-hole"
  replicas: 1
  template:
    metadata:
      labels:
        app.kubernetes.io/name: pi-hole
        pi.hole/role: read-write
    spec:
      topologySpreadConstraints:
      - maxSkew: 1
        topologyKey: kubernetes.io/hostname
        whenUnsatisfiable: ScheduleAnyway
        labelSelector:
          matchLabels:
            app.kubernetes.io/name: pi-hole
      containers:
      - name: pi-hole
        image: pihole/pihole:2025.11.1
        envFrom:
        - configMapRef:
            name: pihole-config
        resources:
          requests:
            memory: 128Mi
            cpu: 100m
        volumeMounts:
        - name: pihole-data
          mountPath: /etc/pihole
        livenessProbe:
          failureThreshold: 3
          timeoutSeconds: 5
          httpGet:
            path: /admin
            port: http
        readinessProbe:
          failureThreshold: 3
          timeoutSeconds: 5
          httpGet:
            path: /admin
            port: http
        ports:
        - containerPort: 80
          name: http
          protocol: TCP
        - containerPort: 53
          name: dns-tcp
          protocol: TCP
        - containerPort: 53
          name: dns-udp
          protocol: UDP
      - name: exporter
        image: ekofr/pihole-exporter
        env:
          - name: PIHOLE_HOSTNAME
            valueFrom:
              fieldRef:
                fieldPath: status.podIP
          - name: PIHOLE_PORT
            value: "80"
          - name: PIHOLE_PASSWORD
            value: "admin"
        resources:
          limits:
            memory: 128Mi
          requests:
            cpu: 50m
            memory: 128Mi
        ports:
          - containerPort: 9617
            name: prometheus
            protocol: TCP
      securityContext:
        fsGroup: 1000
        fsGroupChangePolicy: "OnRootMismatch"
      volumes:
      - name: pihole-data
        persistentVolumeClaim:
          claimName: pihole-data
---
# This service exposes the HTTP admin interface of Pi-hole
apiVersion: v1
kind: Service
metadata:
  name: pi-hole-web
  labels: 
    app.kubernetes.io/name: pi-hole
    pi.hole/role: read-write
spec:
  sessionAffinity: ClientIP
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: 300
  selector:
    app.kubernetes.io/name: pi-hole
    pi.hole/role: read-write
  ports:
  - port: 80
    targetPort: http
    name: http
---
# This HTTPRoute routes traffic to the Pi-hole admin interface
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
  annotations: {}
  name: pihole-https-route
spec:
  hostnames:
  - pihole.ashishverma.dev
  parentRefs:
  - name: envoy
    namespace: envoy-gateway-system
    sectionName: https
  rules:
  - filters:
    - requestRedirect:
        path:
          replaceFullPath: /admin
          type: ReplaceFullPath
        statusCode: 302
      type: RequestRedirect
    matches:
    - path:
        type: Exact
        value: /
  - backendRefs:
    - group: ""
      kind: Service
      name: pi-hole-web
      port: 80
      weight: 1
    matches:
    - path:
        type: PathPrefix
        value: /
---
# This service exposes only the DNS ports of Pi-hole
apiVersion: v1
kind: Service
metadata:
  name: pi-hole-dns
  labels:
    app.kubernetes.io/name: pi-hole
  annotations:
    tailscale.com/expose: "true"
    tailscale.com/hostname: "pihole"
    metallb.io/address-pool: "dns"
spec:
  type: LoadBalancer
  ports:
  - port: 53
    targetPort: 53
    protocol: TCP
    name: dns-tcp
  - port: 53
    targetPort: 53
    protocol: UDP
    name: dns-udp
  selector:
    app.kubernetes.io/name: pi-hole
---
# Read only StatefulSet for Pi-hole
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: pi-hole-ro
  labels:
    app.kubernetes.io/name: pi-hole
    pi.hole/role: read-only
spec:
  serviceName: "pi-hole-ro"
  revisionHistoryLimit: 3
  selector:
    matchLabels:
      app.kubernetes.io/name: pi-hole
      pi.hole/role: read-only
  replicas: 2
  template:
    metadata:
      labels:
        app.kubernetes.io/name: pi-hole
        pi.hole/role: read-only
    spec:
      topologySpreadConstraints:
      - maxSkew: 1
        topologyKey: kubernetes.io/hostname
        whenUnsatisfiable: ScheduleAnyway
        labelSelector:
          matchLabels:
            app.kubernetes.io/name: pi-hole
      containers:
      - name: pi-hole
        image: pihole/pihole:2025.11.1
        envFrom:
        - configMapRef:
            name: pihole-config
        resources:
          requests:
            memory: 128Mi
            cpu: 100m
        volumeMounts:
        - name: pihole-data
          mountPath: /etc/pihole
        livenessProbe:
          failureThreshold: 3
          timeoutSeconds: 5
          httpGet:
            path: /admin
            port: http
        readinessProbe:
          failureThreshold: 3
          timeoutSeconds: 5
          httpGet:
            path: /admin
            port: http
        ports:
        - containerPort: 80
          name: http
          protocol: TCP
        - containerPort: 53
          name: dns-tcp
          protocol: TCP
        - containerPort: 53
          name: dns-udp
          protocol: UDP
      securityContext:
        fsGroup: 1000
        fsGroupChangePolicy: "OnRootMismatch"
      volumes:
      - name: pihole-data
        emptyDir: {}
---
# Service for the read-only Pi-hole StatefulSet
apiVersion: v1
kind: Service
metadata:
  name: pi-hole-ro
  labels: 
    app.kubernetes.io/name: pi-hole
    pi.hole/role: read-only
spec:
  clusterIP: None
  selector:
    app.kubernetes.io/name: pi-hole
    pi.hole/role: read-only
  ports:
  - port: 80
    targetPort: http
    name: http
---
# ConfigMap containing the sync script for Nebula-Sync
---
# ConfigMap containing the adlist sync script
apiVersion: v1
kind: ConfigMap
metadata:
  name: sync-script
data:
  sync.sh: |
    #!/bin/bash
    
    # Colors for output
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    MAGENTA='\033[0;35m'
    CYAN='\033[0;36m'
    NC='\033[0m' # No Color
    
    # Logging functions
    log_info() {
        echo -e "${CYAN}[INFO]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"
    }
    
    log_success() {
        echo -e "${GREEN}[SUCCESS]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"
    }
    
    log_warning() {
        echo -e "${YELLOW}[WARNING]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"
    }
    
    log_error() {
        echo -e "${RED}[ERROR]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"
    }
    
    log_debug() {
        echo -e "${MAGENTA}[DEBUG]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"
    }
    
    log_info "=========================================="
    log_info "Starting Pi-hole Adlist Sync"
    log_info "=========================================="
    
    # Ensure required environment variables are set
    log_info "Checking environment variables..."
    if [[ -z "$PRIMARY_PIHOLE" || -z "$PRIMARY_PIHOLE_PASS" || -z "$REPLICA_PIHOLE" || -z "$REPLICA_PIHOLE_PASS" ]]; then
        log_error "Required environment variables are missing"
        log_debug "PRIMARY_PIHOLE=${PRIMARY_PIHOLE:-'NOT SET'}"
        log_debug "PRIMARY_PIHOLE_PASS=${PRIMARY_PIHOLE_PASS:+'***SET***'}"
        log_debug "REPLICA_PIHOLE=${REPLICA_PIHOLE:-'NOT SET'}"
        log_debug "REPLICA_PIHOLE_PASS=${REPLICA_PIHOLE_PASS:+'***SET***'}"
        exit 1
    fi
    log_success "All required environment variables are set"
    
    # Authenticate with the primary Pi-hole
    log_info "Authenticating with primary Pi-hole: ${PRIMARY_PIHOLE}"
    auth_payload=$(jq -n --arg password "$PRIMARY_PIHOLE_PASS" '{password: $password}')
    log_debug "Auth payload prepared for primary"
    
    auth_response=$(curl -s -X POST -H "Content-Type: application/json" -d "$auth_payload" "$PRIMARY_PIHOLE/api/auth")
    log_debug "Auth response received from primary"
    
    SID=$(echo "$auth_response" | jq -r '.session.sid')
    
    if [[ -z "$SID" || "$SID" == "null" ]]; then
        log_error "Failed to retrieve session token from ${PRIMARY_PIHOLE}"
        log_debug "Auth response: ${auth_response}"
        exit 1
    fi
    log_success "Successfully authenticated with primary Pi-hole"
    log_debug "Session ID: ${SID:0:8}..."
    
    # Fetch enabled adlists from the primary Pi-hole
    log_info "Fetching enabled adlists from primary Pi-hole..."
    response=$(curl -s -H "X-FTL-SID: $SID" "$PRIMARY_PIHOLE/api/lists?type=block")
    log_debug "Lists response received from primary"
    
    addresses=$(echo "$response" | jq -c '[.lists[] | select(.enabled == true) | .address]')
    list_count=$(echo "$addresses" | jq '. | length')
    
    if [[ "$addresses" == "[]" || "$list_count" -eq 0 ]]; then
        log_warning "No enabled lists found on primary Pi-hole"
        log_info "Exiting gracefully"
        exit 0
    fi
    log_success "Found ${list_count} enabled adlists on primary"
    log_debug "Adlist URLs: ${addresses}"
    
    # Define payload
    log_info "Preparing sync payload..."
    payload=$(jq -n --argjson address "$addresses" '{address: $address, comment: "Synced list", groups: [0], enabled: true}')
    log_debug "Payload prepared: ${payload:0:100}..."
    
    # Sync adlists with replicas
    log_info "Starting replica sync process..."
    IFS='|' read -ra REPLICAS <<< "$REPLICA_PIHOLE"
    IFS='|' read -ra PASSWORDS <<< "$REPLICA_PIHOLE_PASS"
    
    log_info "Found ${#REPLICAS[@]} replica(s) to sync"
    
    SUCCESS_COUNT=0
    FAIL_COUNT=0
    
    for index in "${!REPLICAS[@]}"; do
        replica=${REPLICAS[$index]}
        pass=${PASSWORDS[$index]}
        
        log_info "=========================================="
        log_info "Processing replica $((index + 1))/${#REPLICAS[@]}: ${replica}"
        log_info "=========================================="
        
        # Authenticate with replica
        log_info "Authenticating with replica: ${replica}"
        replica_auth_payload=$(jq -n --arg password "$pass" '{password: $password}')
        replica_auth_response=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST -H "Content-Type: application/json" -d "$replica_auth_payload" "$replica/api/auth")
        
        # Extract HTTP status
        http_status=$(echo "$replica_auth_response" | grep "HTTP_STATUS" | cut -d':' -f2)
        replica_auth_response=$(echo "$replica_auth_response" | sed -e 's/HTTP_STATUS:.*//g')
        
        log_debug "HTTP Status: ${http_status}"
        log_debug "Auth response: ${replica_auth_response}"
        
        replica_SID=$(echo "$replica_auth_response" | jq -r '.session.sid')
        
        if [[ -z "$replica_SID" || "$replica_SID" == "null" ]]; then
            log_error "Failed to retrieve session token from ${replica}"
            log_debug "Replica: ${replica}"
            log_debug "Password length: ${#pass}"
            log_debug "Auth payload: ${replica_auth_payload}"
            log_debug "Auth response: ${replica_auth_response}"
            log_debug "Session ID: ${replica_SID}"
            FAIL_COUNT=$((FAIL_COUNT + 1))
            continue
        fi
        log_success "Successfully authenticated with replica"
        log_debug "Replica session ID: ${replica_SID:0:8}..."
        
        # Send adlist data to replica
        log_info "Syncing ${list_count} adlists to replica..."
        sync_response=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST -H "Content-Type: application/json" -H "X-FTL-SID: $replica_SID" -d "$payload" "$replica/api/lists?type=block")
        
        sync_http_status=$(echo "$sync_response" | grep "HTTP_STATUS" | cut -d':' -f2)
        sync_response=$(echo "$sync_response" | sed -e 's/HTTP_STATUS:.*//g')
        
        log_debug "Sync HTTP Status: ${sync_http_status}"
        log_debug "Sync response: ${sync_response}"
        
        if [[ "$sync_http_status" =~ ^2 ]]; then
            log_success "Adlists synced successfully"
        else
            log_warning "Adlist sync returned status ${sync_http_status}"
        fi
        
        # Trigger gravity update on replica
        log_info "Triggering gravity update on replica..."
        gravity_response=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST -H "Content-Type: application/json" -H "X-FTL-SID: $replica_SID" "$replica/api/action/gravity")
        
        gravity_http_status=$(echo "$gravity_response" | grep "HTTP_STATUS" | cut -d':' -f2)
        gravity_response=$(echo "$gravity_response" | sed -e 's/HTTP_STATUS:.*//g')
        
        log_debug "Gravity HTTP Status: ${gravity_http_status}"
        log_debug "Gravity response: ${gravity_response}"
        
        if [[ "$gravity_http_status" =~ ^2 ]]; then
            log_success "Gravity update triggered successfully"
            log_success "Sync completed for ${replica}"
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
        else
            log_error "Gravity update failed with status ${gravity_http_status}"
            FAIL_COUNT=$((FAIL_COUNT + 1))
        fi
    done
    
    log_info "=========================================="
    log_info "Sync Summary"
    log_info "=========================================="
    log_info "Total replicas: ${#REPLICAS[@]}"
    log_success "Successful syncs: ${SUCCESS_COUNT}"
    if [[ $FAIL_COUNT -gt 0 ]]; then
        log_error "Failed syncs: ${FAIL_COUNT}"
    else
        log_info "Failed syncs: 0"
    fi
    log_info "Adlists synced: ${list_count}"
    log_info "=========================================="
    log_success "Pi-hole Adlist Sync Complete"
    log_info "=========================================="
    
    if [[ $FAIL_COUNT -gt 0 ]]; then
        exit 1
    fi
---
# Nebula-Sync for Pi-hole
apiVersion: batch/v1
kind: CronJob
metadata:
  name: pi-hole-sync
spec:
  schedule: "*/15 * * * *"
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: nebula-sync
            image: ghcr.io/lovelaze/nebula-sync:v0.11.1
            env:
            - name: PRIMARY
              value: "https://pihole.ashishverma.dev|admin"
            - name: REPLICAS
              value: "http://pi-hole-ro-0.pi-hole-ro.pi-hole.svc.cluster.local|admin,http://pi-hole-ro-1.pi-hole-ro.pi-hole.svc.cluster.local|admin"
              #value: "http://pi-hole-ro-0.pi-hole-ro.pi-hole.svc.cluster.local|admin"
            - name: FULL_SYNC
              value: 'true'
            - name: RUN_GRAVITY
              value: 'true'
            - name: NS_DEBUG
              value: 'true'
          # - name: adlists-sync
          #   image: alpine:latest
          #   command: ["/bin/sh", "-c", "apk add --no-cache jq bash curl && /script/sync.sh"]
          #   volumeMounts:
          #     - name: script
          #       mountPath: /script
          #   env:
          #     - name: PRIMARY_PIHOLE
          #       value: "https://pihole.ashishverma.dev"
          #     - name: PRIMARY_PIHOLE_PASS
          #       value: admin
          #     - name: REPLICA_PIHOLE
          #       #value: "http://pi-hole-ro-0|http://pi-hole-ro-1"
          #       value: "http://pi-hole-ro-0.pi-hole-ro.pi-hole.svc.cluster.local|http://pi-hole-ro-1.pi-hole-ro.pi-hole.svc.cluster.local"
          #     - name: REPLICA_PIHOLE_PASS
          #       value: "admin|admin"
          #       #value: "<masked-password>|<masked-password>"
          # volumes:
          #   - name: script
          #     configMap:
          #       name: sync-script
          #       defaultMode: 0777
          restartPolicy: OnFailure
---
# Debug only service to access read-only Pi-hole pods
apiVersion: v1
kind: Service
metadata:
  name: pi-hole-web-ro
  labels: 
    app.kubernetes.io/name: pi-hole
    pi.hole/role: read-only
spec:
  type: LoadBalancer
  sessionAffinity: ClientIP
  ports:
  - port: 80
    targetPort: http
    name: http
  selector:
    app.kubernetes.io/name: pi-hole
    pi.hole/role: read-only